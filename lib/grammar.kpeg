%% name = Alt::Parser
%% ast-location = ::Alt::AST
%% assign = ast Assignment(name, expression)
%% method_call = ast MethodCall(receiver, method, arguments)
%% number_literal = ast NumberLiteral(number)
%% true_literal = ast TrueLiteral
%% false_literal = ast FalseLiteral
%% nil_literal = ast NilLiteral

%% {
def shunting_yard(input)
  [].tap do |rpn|
    operator_stack = []
    input.each do |object|
      if op1 = Alt::PrecedenceTable.lookup(object)
        rpn << operator_stack.pop while (op2 = operator_stack.last) && (op1.left_associative? ? op1.precedence <= op2.precedence : op1.precedence < op2.precedence)
        operator_stack << op1
      else
        rpn << object
      end
    end
    rpn << operator_stack.pop until operator_stack.empty?
  end
end

def rpn(input)
  results = []
  input.each do |object|
    if object.is_a?(Alt::AST::Operator)
      r, l = results.pop, results.pop
      results << object.apply(l, r)
    else
      results << object
    end
  end
  results.first
end
}

space = " "
char = /[A-Za-z]/
digit = /[0-9]/

newline = "\n"
terminator = newline (space | newline)*

number = < digit+ ("." digit+)? > { text }
identifier = < char+ > { text }

operators = "||"
          | "&&"
          | "=="
          | "!="
          | "<"
          | "<="
          | ">"
          | ">="
          | "+"
          | "-"
          | "*"
          | "/"
          | "^"

root = expressions

expressions = expressions:es terminator expression:e { es << e }
            | expressions:es terminator { es }
            | expression:e { [e] }
            | terminator
            
expression = call
           | assign
           | literal
           | "(" expression:e ")" { e }
           
literal = number:n ~number_literal(n)
        | "true" ~true_literal
        | "false" ~false_literal
        | "nil" ~nil_literal
     
arg_list = expression     
         | arg_list:al "," expression:e { Array(al) << e }

assign = identifier:i space* "=" space* expression:e ~assign(i,e)

call_operation = space* < operators > space* (expression | identifier):e { [text, e] }
               | < "." > identifier:i "(" arg_list:al ")" { [text, method_call(nil, i, al)] }
               | < "." > identifier:i { [text, method_call(nil, i, [])] }

call_chain = (expression | identifier):e call_operation+:co { co.flatten.unshift(e) }
call = call_chain:cc { rpn(shunting_yard(cc)) }