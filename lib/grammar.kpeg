%% name = Alt::Parser
%% ast-location = ::Alt::AST
%% assign = ast Assignment(name, expression)
%% method_call = ast MethodCall(receiver, method, arguments)
%% number_literal = ast NumberLiteral(number)
%% true_literal = ast TrueLiteral
%% false_literal = ast FalseLiteral
%% nil_literal = ast NilLiteral
%% {
  PRECEDENCE = {"*"   => 5,
                "/"   => 5,
                "+"   => 6,
                "-"   => 6,
                "^"   => 7,
                "<"   => 8,
                "<="  => 8,
                ">"   => 8,
                ">="  => 8,
                "=="  => 9,
                "!="  => 9,
                "<=>" => 10,
                "&&"  => 13,
                "||"  => 14}.freeze
                
  def resolve(a, e, chain)
    return [e, []] if chain.empty?
    b, *rest = chain
    if a && (PRECEDENCE[a] > PRECEDENCE[b] || (PRECEDENCE[a] == PRECEDENCE[b]))
      [e, chain]
    else
      e2, *rest2 = rest
      r, rest3 = resolve(b, e2, rest2)
      resolve(a, method_call(e, b, r), rest3)
    end
  end
}

space = " "
char = /[A-Za-z]/
digit = /[0-9]/

newline = "\n"
terminator = newline (space | newline)*

number = < digit+ > { text }
identifier = < char+ > { text }

operator_chars = /[~`!@#$\%^\&*\\+\-\/?:<=>\|]/
binary_operator = < operator_chars+ > { text }

root = expressions

expressions = expressions:es terminator expression:e { es << e }
            | expressions:es terminator { es }
            | expression:e { [e] }
            | terminator
            
expression = assign
           | operator
           | secondary_expression
           
secondary_expression = call
                     | literal
                     | "(" expression:e ")" { e }
           
literal = number:n ~number_literal(n)
        | "true" ~true_literal
        | "false" ~false_literal
        | "nil" ~nil_literal
        
call = literal:l "." identifier:i "(" arg_list:al ")" ~method_call(l, i, Array(al))
     | literal:l "." identifier:i ~method_call(l, i, [])
     | expression:e "." identifier:i "(" arg_list:al ")" ~method_call(e, i, Array(al))
     | expression:e "." identifier:i ~method_call(e, i, [])
     | identifier:i "(" arg_list:al ")" ~method_call(nil, i, Array(al))
     | identifier:i ~method_call(nil, i, [])
     
     
arg_list = expression     
         | arg_list:al "," expression:e { Array(al) << e }

assign = identifier:i space* "=" space* expression:e ~assign(i,e)

operator = secondary_expression:se operator_chain:oc { resolve(nil, se, oc).first }
operator_chain = (space* binary_operator:o space* secondary_expression:se { [o, se] })+:oc { oc.flatten }